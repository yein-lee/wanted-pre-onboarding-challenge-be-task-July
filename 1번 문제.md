동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.
- Lock과 Transaction을 사용한다.

# Lock
## Optimistic Lock
데이터를 읽을 때 락을 걸지 않는다. 
데이터를 업데이트 할 때, 버전 필드를 통해 데이터가 마지막으로 확인된 이후에 변경되지 않았음을 확인한다. (버전이 일치하는지 확인한다.)
  버전은 업데이트시마다 증가되는 카운터이다.
## Pessimistic Lock
데이터를 읽을 때 락을 걸어 다른 트랜잭션이 데이터를 수정하지 못하게 한다.
동시성이 떨어지는 환경에서는 효과적이지만, 락이 오래 걸려있는 경우 성능 저하를 초래할 수 있다.

# Transaction
데이터베이스 작업의 집합을 묶는 논리적인 단위이다.
AICD 원칙을 따른다.
## ACID
### ATOMICITY
트랜잭션 내의 모든 작업이 완전히 수행되거나 수행되지 않아야 한다.
즉 모든 작업이 성공하거나, 하나라도 실패하면 모든 작업이 취소돼야 한다.
### CONSISTENCY
트랜잭션이 데이터베이스를 일관된 상태로 유지해야 한다.
제약 조건(데이터 유형, 고유성, 참조 무결성 등)이 트랜잭션 이후에도 유지되어야 한다.
- 참조 무결성 (Referential Integrity)
  - FK 값이 null이거나 참조하는 테이블의 기본키값과 일치해야 한다.
  - 참조된 기본키의 값이 변경되거나 삭제될 경우 참조 무결성이 위반될 수 있다. 이를 위해 데이터베이스에서는 다음 전략을 사용한다.
    1. CASCADE: 참조되는 행이 삭제되거나 변경되면, 그에 따라 참조하는 행도 삭제하거나 변경한다.
    2. SET NULL: 참조되는 행이 삭제되거나 변경되면, 참조하는 행의 외래 키 값을 null로 설정한다.
    3. SET DEFAULT: 참조되는 행이 삭제되거나 변경되면, 참조하는 행의 외래 키 값을 기본 값으로 설정한다.
    4. NO ACTION: 참조되는 행이 삭제되거나 변경되는 것을 차단한다.
### ISOLATION
동시에 여러 트랜잭션이 실행되더라도, 각 트랜잭션은 서로 독립적으로 실행되는 것처럼 보여야 한다.
즉 한 트랜잭션 내에서 수행하는 작업이 다른 트랜잭션에게 보이지 않는다.
### DURABILITY
트랜잭션이 성공적으로 커밋된 이후에는, 해당 트랜잭션에 의해 만들어진 결과는 영구적이어야 한다.
즉, 데이터베이스 시스템이 실패하더라도 커밋된 트랜잭션의 결과는 보존되어야 한다.

## Isolation Levels
한 트랜잭션에서 다른 트랜잭션이 동시에 수행하는 작업을 어느 정도로 보게할 것인지를 결정한다.
|  | DIRTY READ | NON-REPEATABLE READ | PAHNTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | o | o | o |
| READ COMITTED | x | o | o |
| REPEATABLE READ | x | x | o (InnoDB는 x) |
| SERIALIZABLE READ | x | x | x |
### READ UNCOMMITTED
한 트랜잭션에서 다른 트랜잭션의 아직 커밋되지 않은 변경사항을 볼 수 있다.
Dirty Read를 허용한다.
### READ COMMITTED
한 트랜잭션에서 다른 트랜잭션에서의 커밋된 변경사항을 볼 수 있다.
Non-repeatable Read와 Phantom Read를 허용한다.
같은 트랜잭션 내에서 데이터를 다시 읽었을 때 다른 결과를 얻을 수 있다.
### REAPEATABLE READ
트랜잭션 도중에 같은 데이터를 여러번 읽어도 처음에 읽은 데이터와 동일하게 보장된다.
즉, 한 트랜잭션에서 수행되는 다른 트랜잭션의 변경사항이 이 트랜잭션에 영향을 주지 않는다.
Phantom Read를 허용한다.
### SERIALIZABLE
모든 트랜잭션을 순차적으로 실행하여 동시성 문제를 완전히 피한다.

### DIRTY READ
트랜잭션에서의 변경 내용이 commit, rollback 여부와 상관 없이 다른 트랜잭션에서 보인다.
### NON-REPEATABLE READ
하나의 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때, 두 번째 결과가 달라지는 경우이다.
첫 번째 쿼리와 두 번째 쿼리 사이에 다른 트랜잭션이 해당 데이터를 수정하고 커밋했을 때 발생한다.
### PHANTOM READ
한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때, 첫 번째 쿼리에서 없던 행이 두 번째 쿼리에서 나타나는 경우이다.
첫 번째 쿼리와 두 번째 쿼리 사이에 다른 트랜잭션이 새로운 행을 추가하고 커밋했을 때 발생한다.
